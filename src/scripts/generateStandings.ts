import fs from 'fs'
import { JSDOM } from 'jsdom'
import resultsData from '../data/results'
import standingsData from '../data/standings'
import seasonRacersData from '../data/seasonRacers'
import trackData from '../data/tracks.json'
import driversData from '../data/drivers.json'
import {
  type RacerResults,
  type TrackName,
  type SeasonName,
  type Tracks,
  type SeasonRacers,
  type RacerName,
  type ConstructorResult
} from '../types'
import { pointsScheme } from '../utils'

type GeneratedConstructorStandings = {
  [index: string]: ConstructorResult
}

type GeneratedRaceStandings = {
  [index: string]: number
}

type GeneratedStandings = {
  [index: string]: GeneratedRaceStandings | GeneratedConstructorStandings | null
}

const standardDriverCount = 2
const autoGeneratedSeasons = ['s4']

const timeGrabber = async (link: string) => {
  const response = await fetch(link)
  const html = await response.text()
  const dom = new JSDOM(
    html
      .replace(/<style([\S\s]*?)>([\S\s]*?)<\/style>/gim, '')
      .replace(/<script([\S\s]*?)>([\S\s]*?)<\/script>/gim, '')
  )

  const table = dom.window.document.querySelector('table')

  const results: Record<string, string> = {}
  const fastestLap = {
    racerId: 'unknown',
    time: '23:59:999'
  }

  if (table) {
    const times = Array.from(table.querySelectorAll('tr'))
      .map((row) => {
        const cells = row.querySelectorAll('td')
        const driver = cells[1]
        const totalTime = cells[3]
        const bestLap = cells[5]

        if (driver && totalTime && bestLap) {
          return [
            driver.innerHTML.split('\n')[0],
            totalTime.innerHTML,
            bestLap.innerHTML.split('<')[0]
          ]
        }

        return []
      })
      .slice(1)

    let lapCounter = 0

    times.forEach((time, index) => {
      const tableName = time[0]
      const name =
        Object.entries(driversData).find(
          (driver) => (driver[1] as { tableName: string }).tableName === tableName
        )?.[0] ?? tableName

      let parsedTime = time[1].split(':').slice(1).join(':')

      if (index > 0) {
        parsedTime = (
          (Date.parse(`01/01/2000 ${time[1]}`) - Date.parse(`01/01/2000 ${times[index - 1][1]}`)) /
          1000
        )
          .toFixed(3)
          .toString()
      }

      if (parsedTime.startsWith('-')) {
        lapCounter++
        parsedTime = `${lapCounter} lap${lapCounter === 1 ? '' : 's'}`
      } else if (lapCounter > 0) {
        parsedTime = `${lapCounter} lap${lapCounter === 1 ? '' : 's'}`
      }

      results[name] = parsedTime

      if (
        time[2] !== '00:00.000' &&
        Date.parse(`01/01/2000 00:${time[2]}`) < Date.parse(`01/01/2000 00:${fastestLap.time}`)
      ) {
        fastestLap.time = time[2]
        fastestLap.racerId = name
      }
    })
  }

  return { results, fastestLap }
}

const calculateStandings = (season: SeasonName) => {
  const seasonRaces = Object.keys(resultsData[season])

  // Compile initial race scores into standings objects
  const points = seasonRaces.reduce((racesObj: GeneratedStandings, race: string) => {
    const raceResults = (resultsData[season] as RacerResults)[race as TrackName]
    const noPointsRace = (trackData as Tracks)[race as TrackName].noPoints

    const points = raceResults
      ? Object.entries(raceResults.results).reduce(
          (obj: GeneratedRaceStandings, item: [string, string], currentIndex) => {
            const dnf = item[1] === 'DNF'
            const cumulativePoints =
              (pointsScheme[season][currentIndex] ?? 0) +
              (raceResults.fastestLap.racerId === item[0] ? 1 : 0)

            return (obj[item[0]] = noPointsRace || dnf ? 0 : cumulativePoints), obj
          },
          {}
        )
      : null

    return (racesObj[race] = points), racesObj
  }, {})

  // Add the points for each driver cumulatively, and reorder
  const raceKeys = Object.keys(points)

  raceKeys.forEach((race, index) => {
    if (points[race] === null) {
      return
    }

    const racePoints = points[race] as GeneratedRaceStandings
    if (index > 0) {
      const previousRacePoints = points[raceKeys[index - 1]] as GeneratedRaceStandings
      Object.keys(racePoints).forEach((driver) => {
        racePoints[driver] += previousRacePoints[driver] ?? 0
      })
    }

    points[race] = Object.entries(racePoints)
      .sort(([, a], [, b]) => b - a)
      .reduce((r, [k, v]) => ({ ...r, [k]: v }), {})
  })

  return points
}

const calculateConstructors = (season: SeasonName) => {
  const seasonRaces = Object.keys(standingsData[season])

  // Compile initial race scores into standings objects
  const points = seasonRaces.reduce((racesObj: GeneratedStandings, race: string) => {
    const standings = (standingsData[season] as GeneratedRaceStandings)[race as TrackName]
    const noPointsRace = (trackData as Tracks)[race as TrackName].noPoints

    const points = standings
      ? Object.entries(standings).reduce((obj: GeneratedConstructorStandings, standing) => {
          const seasonRacer = (seasonRacersData[season as SeasonName] as SeasonRacers)[
            standing[0] as RacerName
          ]
          const car = seasonRacer.otherCars?.[race] ?? seasonRacer.car

          const driverCount = (obj[car]?.driverCount ?? 0) + 1
          const standardPoints = (obj[car]?.points ?? 0) + standing[1]

          return (
            (obj[car] = {
              points: noPointsRace ? 0 : standardPoints,
              normalisedPoints: noPointsRace ? 0 : standardPoints,
              driverCount
            }),
            obj
          )
        }, {})
      : null

    if (points) {
      Object.entries(points).map((constructor) => {
        points[constructor[0]].normalisedPoints = Math.round(
          constructor[1].points * (standardDriverCount / constructor[1].driverCount)
        )
      })
    }

    return (racesObj[race] = points), racesObj
  }, {})

  const raceKeys = Object.keys(points)

  raceKeys.forEach((race, index) => {
    if (points[race] === null) {
      return
    }

    const racePoints = points[race] as GeneratedConstructorStandings
    if (index > 0) {
      const previousRacePoints = points[raceKeys[index - 1]] as GeneratedConstructorStandings
      Object.keys(racePoints).forEach((driver) => {
        racePoints[driver] = {
          points: racePoints[driver].points + previousRacePoints[driver].points ?? 0,
          normalisedPoints:
            racePoints[driver].normalisedPoints + previousRacePoints[driver].normalisedPoints,
          driverCount: racePoints[driver].driverCount
        }
      })
    }

    points[race] = Object.entries(racePoints)
      .sort(([, a], [, b]) => b.normalisedPoints - a.normalisedPoints)
      .reduce((r, [k, v]) => ({ ...r, [k]: v }), {})
  })

  return points
}

const generateStandings = () => {
  autoGeneratedSeasons.forEach(async (season) => {
    if (process.argv[2] === 'add') {
      const parsedResults = await timeGrabber(process.argv[5])

      const resultsPath = `src/data/results/${process.argv[3]}.json`
      const resultsFile = JSON.parse(fs.readFileSync(resultsPath, 'utf8'))

      resultsFile[process.argv[4]] = parsedResults

      fs.writeFileSync(resultsPath, JSON.stringify(resultsFile), { flag: 'w' })
    }

    const standings = JSON.stringify(calculateStandings(season as SeasonName))
    const standingsPath = `src/data/standings/${season}.json`

    try {
      fs.writeFileSync(standingsPath, standings, { flag: 'w' })
      console.log(`${season} standings data saved to file successfully.`)
    } catch (error) {
      console.error('Error writing JSON data to file:', error)
    }

    const constructors = JSON.stringify(calculateConstructors(season as SeasonName))
    const constructorsPath = `src/data/constructors/${season}.json`

    try {
      fs.writeFileSync(constructorsPath, constructors, { flag: 'w' })
      console.log(`${season} constructors data saved to file successfully.`)
    } catch (error) {
      console.error('Error writing JSON data to file:', error)
    }
  })
}

if (process) {
  generateStandings()
}
